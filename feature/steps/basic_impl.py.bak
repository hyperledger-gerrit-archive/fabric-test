# Copyright IBM Corp. 2016 All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from behave import *
import time
import os
import compose_util
import orderer_util
import config_util


ORDERER_TYPES = ["solo",
                 "kafka",
                 "solo-msp"]

PROFILE_TYPES = {"solo": "SampleInsecureSolo",
                 "kafka": "SampleInsecureKafka",
                 "solo-msp": "SampleSingleMSPSolo"}


@given(u'I wait "{seconds}" seconds')
@when(u'I wait "{seconds}" seconds')
@then(u'I wait "{seconds}" seconds')
def step_impl(context, seconds):
    time.sleep(float(seconds))

@given(u'we compose "{composeYamlFile}"')
def compose_impl(context, composeYamlFile):
    composition = compose_util.Composition(context, composeYamlFile)
    context.compose_containers = composition.containerDataList
    context.composition = composition

@given(u'I have a bootstrapped fabric network')
def step_impl(context):
    bootstrapped_impl(context, "solo")

@given(u'I have a bootstrapped fabric network of type {networkType}')
def bootstrapped_impl(context, networkType):
    assert networkType in ORDERER_TYPES, "Unknown network type '%s'" % networkType
    curpath = os.path.realpath('.')
    context.composeFile = "%s/docker-compose/docker-compose-%s.yml" % (curpath, networkType)
    profile = PROFILE_TYPES.get(networkType, "SampleInsecureSolo")
    channelID = "initchannel"
    config_util.generateConfig(context, channelID, profile)
    config_util.generateCrypto(context)
    compose_impl(context, context.composeFile)
    registerUsers(context)

@given(u'{component} is taken down')
def step_impl(context, component):
    pass

@when(u'{component} comes back up')
def step_impl(context, component):
    pass


def gatherTableData(context):
    aliases = []
    data = []
    if 'table' in context and context.table is not None:
        aliases = context.table.headings
        for row in context.table:
            args = row.cells
            data.append(args)
    return aliases, data

def verifyCertificates(context, header, data):
    assert data != [], "There are no users to register to the network"
    assert "certificate" in header, "Certificates must be supplied using keyword 'certificate'"

def registerUsers(context):
    header, data = gatherTableData(context)
    if data == []:
        header = ["username", "password", "certificate"]
        data.append(["testUser0", "unomys3kret", "./certificates/testUser0.pem"])
    verifyCertificates(context, header, data)

    assert data != [], "There are no users to register to the network"
    assert "username" in header, "Usernames must be supplied using keyword 'username'"
    secretMsg = {"enrollId": data[0][0],
                 "enrollSecret": data[0][1]}
#    #context.userRegis = orderer_util.getUserRegistration(context, data[0][0])
#    context.userRegis = orderer_util.registerUser(context, secretMsg, "orderer")
    # If there are no users for this run of test, initialize the structure
    if not hasattr(context, "users"):
        context.users = {}

    # If there is no data for these users, initialize
    for userInfo in data:
        if userInfo[0] not in context.users:
            context.users[userInfo[0]] = lambda: None

        context.users[userInfo[0]].secret = userInfo[1]
